from django.db import models

class Project(models.Model):
    title = models.CharField(max_length=100)
    description = models.TextField()
    image = models.FilePathField(path="/img")

# Project.objects.filter(pk=1).update(description="This method consists in divide the given interval, that has a root, in two sub-intervals of the same size and then evaluates in the boundaries of each sub-interval in takes the one that has a change of sign.")
# Project.objects.filter(pk=2).update(description="The objective of this method is to find the interval that contains at least one root, is based in the medium value theorem that says: 'If f is a continuous function in the interval (a,b)and k is a number between f(a) and f(b), then exists a number c in the interval (a,b) such as f(c)=k.'")
# Project.objects.filter(pk=3).update(description="Also known as the tangent method, the value of x1 is obtained as the point of cut-off with the x axis of the tangent line to the curve y = f(x) in the point (x0,f(x0)), similarly, the value of x2 is obtained as the point of cut with the x axis of the tangent line to the curve y=f(x) that pass through the point (x1, f(x1)) and so on.")
# Project.objects.filter(pk=4).update(description="This method have the same characteristics of Bisection except of the way of calculate the medium point, what we need to do in this method is to find the line that is between the points (a,f(a)) and (b,f(b)) and as one of them is above the axis x and the other one is under it, we can conclude that that line between the two points, passes through the x axis, so the intermediate point xm is were it happens. Then we need to calculate f(xm) and the sign of it, after that, compare it two the signs of f(a) and f(b), with it we can choose the interval were the root is and so on.")
# Project.objects.filter(pk=5).update(description="This method is a variant of the Newton's method, but the aproximation is made by secant lines, this helps with the functions that in the given interval, have its derivate close to zero.")
# Project.objects.filter(pk=6).update(description="This method takes a function f(x) and generates from it a new function x=g(x) that will be the one we'll are going to find a solution for . To do that, we need to find a value of x that keeps constant for the function g(x). See that what we are searching now is the intersection between the line y=x and g(x) and when we find it, it will be in the point were f(x)=0.")
# Project.objects.filter(pk=7).update(description="This method was proposed by Ralston and Rabinowitz in 1978 as a modification from de methods of Newton and Secant, it is used to discover some multiple roots, that wouldn't be able to be discover because don't full fill the conditions od the other methods.")
# Project.objects.filter(pk=8).update(description="This method does two fundamental processes, the first one is to transform the system using some elemental operations until obtain an equivalent system of equations, wich will have a superior trangular matrix and with that, we'll apply regressive substitution to know the result of the system.")
# Project.objects.filter(pk=9).update(description="This is a method derivate of the simple Guassian elimination, the main sifference is that before start doing all the elemental oporations, you have to put in each stage the biggest number of the column, under absolut value, in the a[k][k] position and after that is, do the same process of elemental operations to the column you're at, and repeat all over when it comes to the second one and so on.")
# Project.objects.filter(pk=10).update(description="This is a method derivate of the simple Guassian elimination, the main sifference is that before start doing all the elemental oporations, you have to put in each stage the biggest number of the matrix, under absolut value, in the a[k][k] position and after that is, do the same process of elemental operations to the column you're at, and repeat all over when it comes to the second column and so on.")
# Project.objects.filter(pk=11).update(description="This is a method to solve an interpolation problem, given a set of n+1 known points, it can be voiced as {(x0,y0),(x1,y1),(x2,y2)...}, Be f a function define in the interval [a,b] such that for all i=0,1,...,n fullfill that xiE[a,b] and then exists a single polynomial such that p(xi)=f(xi) and it can be voiced as p(x)n=f[x0]+f[x0,x1](x-x0)+f[x0,x1,x2](x-x0)(x-x1)...")
# Project.objects.filter(pk=12).update(description="This method does a direct factorization of the matrix LU=A , with the condition that the diagonal of the matrix U will be fill with ones.")
# Project.objects.filter(pk=13).update(description="This is one of the iterative methods for solving linear equations of the form Ax=b, we define the matrix L as the matriz made by the enter matrix's inferior diagonal, without the diagonal. The matrix D as the diagonal of the entered matrix and the matrix U as the superior diagonal of the entered matrix, without the diagonal. With this three matrices we can define a new matrix Tg=(D-L)^-1*U and a vector Cg=(D-L)^-1*b")
# Project.objects.filter(pk=14).update(description="This is one of the iterative methods for solving linear equations of the form Ax=b, we define the matrix L as the matriz made by the enter matrix's inferior diagonal, without the diagonal. The matrix D as the diagonal of the entered matrix and the matrix U as the superior diagonal of the entered matrix, without the diagonal. With this three matrices we can define a new matrix Tj=D^-1(L+U) and a vector Cj=D^-1b")
# Project.objects.filter(pk=15).update(description="The method of LU factorization with simple Gaussian elimination is achieved by dividing the entered matrix in two different ones, the matrix L will be made by ones in it's diagonal and with it's multiplicators en the inferior triangle, and the matrix U is going to be made by de superior triangle of the enter matrix, without the elements of the diagoanal.")
# # 
# Project.objects.filter(pk=16).update(description="Given the identity matrix I, there will be a matrix P obtain by the row exchange sequence of I. Be Ax=b an equation system and A an invertible matrix, then it exists a permutation matrix P such that PA admitts a factorization as the product of the triangle matrices PA=LU.Let's assume that the system Ax=b can be solved by using Guassian elimination with partial pivoting, then it exists a matrix P such as the product PA can be factorized as the producto of a triangle inferior matrix L and a triangle superior matrix U, PA=LU")

# Project.objects.filter(pk=17).update(description="The Succesive Over Relaxation or SOR is a metod that improve the developmet of the Gauss Seidel method and it could also be apply to other methods as Jacobi, in this case, the matrix Tw=(D-wL)^-1[(1-w)D+wU] and the vector Cw=w*(D-wL)^-1*b, taking w as the final value of the aproximation of the component i en the stage K.")
# Project.objects.filter(pk=18).update(description="TThis is a method for numerical integration, in this case it approximates the function to the linear polynomial of Lagrange of the form p1(x)=mx+b, also it is defined by the points (a,f(a)) and (b,f(b)), geometrically, the polynomialis is the secant line that goes throughthe points (a,f(a)) and (b,f(b)), and then, the area under the curve y=f(x) is approximately the area under de points (a,f(a)) and (b,f(b)).")
# Project.objects.filter(pk=19).update(description="This is a method for numerical integration, in this case it approximates the function to the quadratic polynomial of Lagrange of the form p2(x), to do that, we choose three points as the base of the interpolation, this will be related with the integration limits that conform the ends of the interval and the medium point between them. Then we'll choose the points x0,x1,x2 where x0=a, x2=b and x1=(a+b)/2; then we calculate the area under the quadratic polynomial of Lagrange, and it will be a closer aproximation of the value of the inicial function.")
# Project.objects.filter(pk=20).update(description="This is a method for numerical integration, in this case it approximates the function to the cubic polynomial of Lagrange of the form p3(x), to do that, we choose four points as the base of the interpolation, this will be related with the integration limits that conform the ends of the interval and the two medium points between them. Then we'll choose the points x0,x1,x2,x3 where x0=a, x3=b, x1=x0+(b-a)/3 and x2=x0+2(b-a)/3 ; then we calculate the area under the cubic polynomial of Lagrange, and it will be a closer aproximation of the value of the inicial function.")
# Project.objects.filter(pk=21).update(description="This is a method to solve an interpolation problem, given a set of n+1 known points, it can be voiced as {(x0,y0),(x1,y1),(x2,y2)...} and then we can consider a polynomial of the form p(x)=an*x^n+an-1*x^n-1+an-2*x^n-2+an-3*x^n-3+an*x-4^n-4+...")
# Project.objects.filter(pk=22).update(description="This method does a direct factorization of the matrix LU=A , with the condition that the diagonal of the matrix L will be equal to the diagonal of the matrix U.")
# p23 = Project(title='Crout', description='This method does a direct factorization of the matrix LU=A , with the condition that the diagonal of the matrix L will be fill with ones.',image='')
# p24 = Project(title='Lagrange', description="This is a method to solve an interpolation problem, given a set of n+1 known points, it can be voiced as {(x0,y0),(x1,y1),(x2,y2)...}  wich it's abscissas are different two at two, we want obtain a polynomial p(x) with the lower grade possible such as p(xi)=f(xi) for all i=0,1,2,...,n. The Lagrange polynomial can be seen as p(x)=a0f(x0)+a1f(x1)+a2f(x2)+...+anf(xn)",image='')

# Project.objects.filter(pk=1).update(title= "Bisection")
# Project.objects.filter(pk=2).update(title= "Incremental Search")
# Project.objects.filter(pk=4).update(title= "False position")
# Project.objects.filter(pk=5).update(title= "Secant")
# Project.objects.filter(pk=6).update(title= "Fixed point")
# Project.objects.filter(pk=7).update(title= "Multiple roots")
# Project.objects.filter(pk=8).update(title= "Guassian elimination")
# Project.objects.filter(pk=9).update(title= "Parcial pivoting")
# Project.objects.filter(pk=10).update(title= "Total pivoting")
# Project.objects.filter(pk=11).update(title= "Divided Differences")
# Project.objects.filter(pk=15).update(title= "LU simple")
# Project.objects.filter(pk=16).update(title= "LU partial")
# Project.objects.filter(pk=18).update(title= "Linear Spline")
# Project.objects.filter(pk=19).update(title= "Quadratic Spline")
# Project.objects.filter(pk=20).update(title= "Cubic Spline")
